import { getRandomMateIn1Fen } from "./genPuzzle";
import { Chess } from "chess.js";
import { getRandomInt } from "./util";
import fs from "fs";

// Types and interfaces
export interface CaptchaSecret {
  fen: string;
  expireAt: number;
}

export interface CaptchaConfig {
  queueCapacity: number;
  expirationTime: number;
  filename?: string;
}

export interface CaptchaResult {
  fen: string;
  expireAt: number;
}

// Main ChessCaptcha class
export class ChessCaptcha {
  private fenQueue: string[] = [];
  private config: CaptchaConfig;
  private preFENlist: string[] = [];
  private isRefilling: boolean = false;
  private generationPromise: Promise<void> | null = null;
  private refillPromise: Promise<void> | null = null;

  constructor(config: Partial<CaptchaConfig> = {}) {
    this.config = {
      queueCapacity: 3,
      expirationTime: 180, // 3 minutes in seconds
      ...config,
    };
    this.fenQueue = [];
    if (this.config.expirationTime <= 0) {
      throw new Error("Expiration time must be greater than 0");
    }

    if (this.config.queueCapacity < 0) {
      throw new Error("Queue capacity must be greater or equal to 0");
    }
  }

  /**
   * Initialize the queue with pre-generated puzzles
   */
  async init(): Promise<void> {
    if (this.config.filename) {
      const resolvedPath = this.config.filename;

      if (resolvedPath.endsWith(".csv")) {
        this.preFENlist = this.readFenCsv(resolvedPath);
        return;
      } else {
        throw new Error("Invalid file extension. Only .csv is supported");
      }
    }
    for (let i = 0; i < this.config.queueCapacity; i++) {
      const { fen } = await getRandomMateIn1Fen();
      if (fen === "") continue;
      this.fenQueue.push(fen);
    }
  }

  /**
   * Get a mate-in-1 captcha puzzle
   * @returns Promise<CaptchaResult> - The puzzle FEN and expiration time
   */
  async getMateIn1Captcha(): Promise<CaptchaResult> {
    // if user provided a list of FENs, return a random FEN from the list (not generated by Stockfish)
    if (this.preFENlist.length > 0) {
      const randomIndex = getRandomInt(0, this.preFENlist.length - 1);
      return {
        fen: this.preFENlist[randomIndex],
        expireAt: Date.now() + this.config.expirationTime * 1000,
      };
    }

    if (this.fenQueue.length > 0) {
      const fen = this.fenQueue.shift();
      if (!fen) {
        throw new Error("Failed to generate captcha");
      }
      // Refill the queue after returning
      this.refillQueue();
      return {
        fen,
        expireAt: Date.now() + this.config.expirationTime * 1000,
      };
    }

    const { fen } = await getRandomMateIn1Fen();
    if (fen === "") {
      throw new Error("Failed to generate captcha");
    }

    this.refillQueue();
    return {
      fen,  
      expireAt: Date.now() + this.config.expirationTime * 1000,
    };
  }

  private ensureFirstCaptchaExists(): Promise<void> {
    // 3. 이미 다른 요청이 '대표'가 되어 캡차를 만들고 있다면,
    // 그 작업이 끝나기를 함께 기다립니다.
    if (this.generationPromise) {
      return this.generationPromise;
    }

    // 4. 아무도 캡차를 만들고 있지 않다면, 내가 '대표'가 됩니다.
    this.generationPromise = (async () => {
      try {
        // 큐가 여전히 비어있을 때만 딱 하나를 생성합니다.
        if (this.fenQueue.length === 0) {
          const { fen } = await getRandomMateIn1Fen();
          if (fen === "") throw new Error("Failed to generate captcha");
          this.fenQueue.push(fen);
        }
      } catch (error) {
        // 실패 시에도 Promise를 반환하여 다른 요청의 대기를 풀어줘야 함
        throw error;
      } finally {
        // 5. 작업이 끝나면 (성공/실패 무관) '대표' 자리를 비워줍니다.
        this.generationPromise = null;
      }
    })();

    return this.generationPromise;
  }

  /**
   * Verify a captcha answer
   * @param secret - The captcha secret containing FEN and expiration
   * @param answer - The move answer in format "e2e4"
   * @returns boolean - True if answer is correct and not expired
   */
  async verifyCaptcha(secret: CaptchaSecret, answer: string): Promise<boolean> {
    // Check if expired
    if (secret.expireAt < Date.now()) {
      return false;
    }

    try {
      const game = new Chess(secret.fen);
      const move = game.move({
        from: answer.slice(0, 2),
        to: answer.slice(2, 4),
      });

      return move && game.isCheckmate();
    } catch (error) {
      // Invalid move or FEN
      return false;
    }
  }

  /**
   * Read FENs from a CSV file (one FEN per line, comma or newline separated)
   * @param filename - Path to the CSV file
   * @returns string[] - Array of FEN strings
   */
  private readFenCsv(filename: string): string[] {
    const data = fs.readFileSync(filename, "utf8");
    // Split by newlines, extract first column from each line, and filter out empty strings
    return data
      .split(/\r?\n/)
      .slice(1)
      .map((line) => line.split(",")[0]) // Extract only the first column
      .map((fen) => fen.trim())
      .filter((fen) => fen.length > 0);
  }

  /**
   * Refill the queue to maintain capacity
   */
  private async refillQueue(): Promise<void> {
    if (this.refillPromise) {
      return;
    }
    if (this.fenQueue.length >= this.config.queueCapacity) return;

    this.refillPromise = (async () => {
      try {
        while (this.fenQueue.length < this.config.queueCapacity) {
          const { fen } = await getRandomMateIn1Fen();

          if (fen === "") continue;
          this.fenQueue.push(fen);
        }
      } catch (error) {
        throw error;
      } finally {
        this.refillPromise = null;
      }
    })();
  }
}